<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java-基本数据结构-使用指南</title>
    <link href="/2021/11/12/Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2021/11/12/Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>从8月份开始陆陆续续用Java在leetcode上刷了350+的题目，算是把一些基本的Java数据结构用过来一边了。想起上半年实习的时候还一点Java不会，渐渐算是熟悉了Java语言。</p><p>一些比较深入的redis/springboot，只是在公司的时候了解过一些，没有这方面的项目，因此这里就不涉及了。这些东西感觉有了Java的语感，就是API的使用问题，到时候再学习。这里主要集中整理基本数据结构的使用。</p><h2 id="比较常用的数据结构："><a href="#比较常用的数据结构：" class="headerlink" title="比较常用的数据结构："></a>比较常用的数据结构：</h2><p>int, long, char是基本类型，Integer, Long, Character, String等是类。类的特征就是他可以是null的。</p><p>一般情况下,JDK1.5/Java 5有一个新特性就是支持自动装包/解包，意思是int &lt;-&gt; Integer的转换可以隐式的进行。一些情况下，如int[] &lt;-&gt; List<Integer> 就需要自己调用函数了。</p><h2 id="一些Trick"><a href="#一些Trick" class="headerlink" title="一些Trick"></a>一些Trick</h2><ol><li><p>定义数组并填充数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++) &#123;<br>    Arrays.fill(dp[i], -<span class="hljs-number">1</span>); <span class="hljs-comment">// 实现逐行填充dp内容为-1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>List只是接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList(); <span class="hljs-comment">// 随机读取是O(1)</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList(); <span class="hljs-comment">// 随机读取是O(n)</span><br></code></pre></td></tr></table></figure></li><li><p>List和Arrar互相转化</p></li></ol><ul><li>Array转List<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] s = <span class="hljs-keyword">new</span> String[] &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;;<br>List&lt;String&gt; list = Arrays.asList(s); <span class="hljs-comment">// 值得注意的是，s的修改会直接影响到list，因此为了避免意外</span><br><span class="hljs-comment">// 最好采取下面的方式</span><br>List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>);<br><span class="hljs-comment">// 或者</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList(Arrays.asList(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>))<br></code></pre></td></tr></table></figure></li><li>List转Array<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] dest = list.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 一是这里dest和list的空间不同，一个修改不影响另一个</span><br><span class="hljs-comment">// 二是 new String[0]这里不仅指定了返回的类型，还指定了空间；写为0，则会自动按照list大小重新开辟空间。写0和list大小都可以，但是不能省略</span><br></code></pre></td></tr></table></figure></li></ul><ol><li>int[] 转 List<Integer><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.stream(ints).boxed().collect(Collectors.toList());<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Arrays.stream(ints) 是生成了intStream流，流中元素为int而不是Integer，因此需要使用boxed()打包</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">** 区别于Arrays.asList(ints).stream()则是在asList()中做了int到Integer的转化，出来的是Integer Stream流。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="常用模板"><a href="#常用模板" class="headerlink" title="常用模板"></a>常用模板</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 二分法可以是分而治之的思想，也可以是删除法的思想</span><br><span class="hljs-comment">// leetcode: 162.寻找峰值</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> solution2(nums);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">solution2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> b = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (a &lt; b) &#123;<br>            <span class="hljs-keyword">int</span> mid = (a+b) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[mid+<span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 由于mid总是靠左，mid+1总是不会越界的</span><br>                a = mid+<span class="hljs-number">1</span>; <span class="hljs-comment">// 保证新的区间[mid+1, b] nums[b] &gt; nums[b+1], 且nums[mid+1] &gt; nums[mid], 即还是有峰值在该区间</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                b = mid; <span class="hljs-comment">// 保证新的区间[a, mid] nums[a] &gt; nums[a-1], 且 nums[mid] &gt;= nums[mid+1], 即还是有峰值在该区间</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最后区间为[a, a] 有，nums[a] &gt; nums[a+1] 且 nums[a] &gt; nums[a-1], 因此a位置处就是峰值</span><br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="bfs-广度优先"><a href="#bfs-广度优先" class="headerlink" title="bfs, 广度优先"></a>bfs, 广度优先</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode: 102. 二叉树的层序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-comment">// 所谓层序遍历，就是bfs搜索过程中的queue中添加的顺序</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">int</span> num = queue.size();<br>            List&lt;Integer&gt; clist = <span class="hljs-keyword">new</span> ArrayList();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;num; i++) &#123;<br>                TreeNode node = queue.poll();<br>                clist.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);<br>            &#125;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(clist));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dfs-深度优先"><a href="#dfs-深度优先" class="headerlink" title="dfs, 深度优先"></a>dfs, 深度优先</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode: 94. 二叉树的中序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">// 中序遍历，应该把根节点放在中间</span><br>        <span class="hljs-comment">// 递归到每个节点时候，应该先dfs左做点，然后放入本节点，然后调用右节点</span><br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left);<br>        res.add(root.val);<br>        dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode: 1. 两数之和</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-comment">// solution1() 双指针不能做，数组无序，题目要求返回索引，因此如果双指针，必然要多一些空间或者时间，用于找到对应的索引;</span><br>        <span class="hljs-keyword">return</span> solution2(nums, target);<br>        <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] solution2(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-comment">// HashMap()解法</span><br>        Map&lt;Integer, Integer&gt; valueIndex = <span class="hljs-keyword">new</span> HashMap();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (valueIndex.containsKey(target - nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, valueIndex.get(target - nums[i])&#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                valueIndex.put(nums[i], i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Integer&gt; com = <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer n1, Integer n2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Integer.compare(n1, n2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意Comparator的写法，重写compare函数，注意可以使用Integer.compare(Integer, Integer), String::compareTo(String)函数。<br>可以有效避免写法上的复杂，以及Integer越界的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode: 215.数组中的第k个最大元素</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> solution3(nums, k);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">solution3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用小顶堆</span><br>        PriorityQueue&lt;Integer&gt; pqueue = <span class="hljs-keyword">new</span> PriorityQueue(<span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer n1, Integer n2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(n1, n2);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++) &#123;<br>            pqueue.add(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=k; i&lt;nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= pqueue.peek()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pqueue.poll();<br>                pqueue.add(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pqueue.poll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode: 229. 滑动窗口最大值</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">return</span> solution1(nums, k);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] solution1(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-comment">// 更好的方式是使用单调栈, 使用双端队列实现; 因为每个数字只会进入一次出来一次，因此处理每个窗口的平均时间复杂度是O(1)的</span><br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n-k+<span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i]) &#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(i);<br>        &#125;<br>        res[<span class="hljs-number">0</span>] = nums[deque.peekFirst()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=k; i&lt;nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (deque.peekFirst() &lt;= i-k) &#123;<br>                deque.pollFirst();<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i]) &#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(i);<br>            res[i-k+<span class="hljs-number">1</span>] = nums[deque.peekFirst()];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode: 10.正则表达式匹配</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] dp; <span class="hljs-comment">// 1表示true， -1表示false, 0表示还没有搜索到</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> solution1(s, p);<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">solution1</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = s.length();<br>        <span class="hljs-keyword">int</span> n = p.length();<br><br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// 其他f[0][j]和f[i][0]都取默认值false</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (i!=<span class="hljs-number">0</span> &amp;&amp; (p.charAt(j-<span class="hljs-number">2</span>)==<span class="hljs-string">&#x27;.&#x27;</span> || s.charAt(i-<span class="hljs-number">1</span>)==p.charAt(j-<span class="hljs-number">2</span>))) &#123;<br>                        dp[i][j] = dp[i][j - <span class="hljs-number">2</span>] || dp[i - <span class="hljs-number">1</span>][j];<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i][j] = dp[i][j - <span class="hljs-number">2</span>];<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (i!=<span class="hljs-number">0</span> &amp;&amp; (p.charAt(j-<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;.&#x27;</span> || s.charAt(i-<span class="hljs-number">1</span>)==p.charAt(j-<span class="hljs-number">1</span>))) &#123;<br>                        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i][j] = <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为OpenMP学习铺路</title>
    <link href="/2021/11/11/%E4%B8%BAOpenMP%E5%AD%A6%E4%B9%A0%E9%93%BA%E8%B7%AF/"/>
    <url>/2021/11/11/%E4%B8%BAOpenMP%E5%AD%A6%E4%B9%A0%E9%93%BA%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>OpenMP是一种并行程序设计语言，调用多个内核完成任务。根据并行机体系结构的不同、访存模型的不同，并行程序设计模型也有所不同。</p><p>中科院计算机网络信息中心（超级计算中心）提供了一份OpenMP并行编程的分享<sup><a href="#fn_4" id="reffn_4">4</a></sup>。</p><h2 id="连接并行的硬件基础"><a href="#连接并行的硬件基础" class="headerlink" title="连接并行的硬件基础"></a>连接并行的硬件基础</h2><p>并行的基础不再是单核上虚拟多线程，利用计算和io的交替充分利用cpu的时间片，而是现代多cpu/多core/超线程技术下的真并行方案。由于现代并行计算任务往往伴随大数据，因此即使计算任务划分开，每个thread上仍然会有访问memory的冲突。NUMA结构解决了早期SMP体系中前端总线FSB上的瓶颈问题。</p><p><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111164629.png" alt=""></p><h4 id="不同的并行机体系结构以及通信机制适用不用的并行编程模型"><a href="#不同的并行机体系结构以及通信机制适用不用的并行编程模型" class="headerlink" title="不同的并行机体系结构以及通信机制适用不用的并行编程模型"></a>不同的并行机体系结构以及通信机制适用不用的并行编程模型</h4><p>主要有两类：</p><ul><li>SMP: 共享内存并行机</li><li>DSM: 分布共享存储并行机<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111161711.png" alt=""></li></ul><h4 id="访存模型"><a href="#访存模型" class="headerlink" title="访存模型"></a>访存模型</h4><ul><li>多处理器（单个地址空间）， NUMA也是单个地址空间</li><li>多计算机（多个地址空间），通过网络通信连接<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111162022.png" alt=""></li></ul><h4 id="OpenMP-API"><a href="#OpenMP-API" class="headerlink" title="OpenMP API"></a>OpenMP API</h4><p><a href="https://www.openmp.org/specifications/">OpenMP 官网</a><br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111170516.png" alt=""></p><p><a href="https://www.openmp.org/wp-content/uploads/OpenMPRefCard-5.1-web.pdf">OpenMP 5.1 API cheating paper</a><br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111170447.png" alt=""></p><p><a href="https://hpc.llnl.gov/tuts/openMP/#Abstract">OpenMP tutorial</a><br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111170622.png" alt=""></p><p><a href="https://man7.org/linux/man-pages/man3/numa.3.html">NUMA manual page</a><br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111170711.png" alt="20211111170711"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote id="fn_1"><sup>1</sup>. OpenMP 官方网站：<a href="https://www.openmp.org/">OpenMp.org</a>。在此可以找到API定义，常见问题，报告，讨论，多媒体，日程，会员应用等<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://hpc.llnl.gov/">劳伦斯利弗莫尔国家实验室(Lawrence Livermore National Laboratory, LLNL)</a>,在此搜索OpenMP，可以找到openMP的tutorial<sup><a href="#fn_3" id="reffn_3">3</a></sup><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. <a href="https://hpc.llnl.gov/tuts/openMP/#Abstract">OpenMP’s tutorial</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. <a href="https://scc.ustc.edu.cn/zlsc/cxyy/200910/W020121113517997951933.pdf">OpenMP并行编程</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote>]]></content>
    
    
    <categories>
      
      <category>并行编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并行编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OGB-LSC KDD Cup 2021</title>
    <link href="/2021/11/10/OGB-LSC-KDD-Cup-2021/"/>
    <url>/2021/11/10/OGB-LSC-KDD-Cup-2021/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>KDD Cup 全称为国际知识发现和数据挖掘竞赛，自1997年开始，由 ACM 协会 SIGKDD 分会每年举办一次，目前是全球数据挖掘领域最有影响力的赛事，其所设比赛题目具有相当高的实际意义和商业价值。多年来，该赛事每年都吸引着众多世界顶级的 AI 研究机构与企业的参与，并且催生了大量的经典比赛和经典算法。</p><p>今年，KDD Cup 2021 首次与斯坦福大学图神经网络权威 Jure Leskovec 教授领导 Open Graph Benchmark（OGB）团队合作，联合举办第一届 OGB Large-Scale Challenge，共有500余个来自全球各地的队伍参赛。</p><h2 id="KDD-Cup-2021"><a href="#KDD-Cup-2021" class="headerlink" title="KDD Cup 2021"></a>KDD Cup 2021</h2><p>KDD Cup 2021分为三个赛道：MAG240M-LSC track, WikiKG90M-LSC track, PCQM4M-LSC track。其中MAG240M-LSC比赛使用了来自Microsoft Academic Graph的学术异质图，其中有三类关系：cites(between 2 paper nodes), writes(between author node and paper node), and affiliated with(between author node and instutition node)。涉及总共121M篇论文，122M个作者，26K个机构。</p><p>比赛中使用至2018年之前的论文作为训练集，2019年作为验证集，2020年作为测试集。</p><p><strong>ps.</strong> </p><ol><li><p>由于自己在准备的比赛和node classification相关，故本文主要整理MAG240M-LSC的成果。</p></li><li><p>相比于直接看论文，这些比赛中使用的方法往往是真正前沿且可复现的方法。一路看过来，其论文更加言简意赅，并且开源所有代码。无论是初学者，还是业内人士都能快速捕获最新进展。</p></li></ol><h2 id="Winners"><a href="#Winners" class="headerlink" title="Winners"></a>Winners</h2><h4 id="1st-place-BD-PGL"><a href="#1st-place-BD-PGL" class="headerlink" title="1st place: BD-PGL"></a>1st place: BD-PGL</h4><ul><li><strong>Team members:</strong> Yunsheng Shi (Baidu), Zhengjie Huang (Baidu), Weibin Li (Baidu), Weiyue Su (Baidu), Shikun Feng (Baidu)</li><li><strong>Method:</strong> R-UNIMP</li><li><strong>Test Accuracy:</strong> 0.7549</li></ul><h4 id="2nd-place-Academic"><a href="#2nd-place-Academic" class="headerlink" title="2nd place: Academic"></a>2nd place: Academic</h4><ul><li><strong> Team members:</strong> Petar Velickovic (DeepMind), Peter Battaglia (DeepMind), Jonathan Godwin (DeepMind), Alvaro Sanchez (DeepMind), David Budden (DeepMind), Shantanu Thakoor (DeepMind), Jacklynn Stott (DeepMind), Ravichandra Addanki (DeepMind), Thomas Keck (DeepMind), Andreea Deac (DeepMind)</li><li><strong> Method: </strong> MPNN Ensemble with BGRL fine-tuning</li><li><strong> Test Accuracy: </strong> 0.7519</li></ul><h4 id="3rd-place-Synerise-AI"><a href="#3rd-place-Synerise-AI" class="headerlink" title="3rd place: Synerise AI"></a>3rd place: Synerise AI</h4><ul><li><strong> Team members:</strong> Michal Daniluk (Synerise), Jacek Dabrowski (Synerise), Konrad Goluchowski (Synerise), Barbara Rychalska (Warsaw University of Technology/Synerise)</li><li><strong> Method: </strong> Cleora + EMDE</li><li><strong> Test Accuracy: </strong> 0.7460</li></ul><h2 id="Runner-ups"><a href="#Runner-ups" class="headerlink" title="Runner-ups"></a>Runner-ups</h2><h4 id="4th-place-Topology-mag"><a href="#4th-place-Topology-mag" class="headerlink" title="4th place: Topology_mag"></a>4th place: Topology_mag</h4><ul><li><strong>Team members:</strong> Qiuying Peng (OPPO Research), Wencai Cao (OPPO Research), Zheng Pan (OPPO Research)</li><li><strong>Method:</strong> MPLP + finetune (40 ensemble)</li><li><strong>Test Accuracy:</strong> 0.7447</li></ul><h4 id="5th-place-passages"><a href="#5th-place-passages" class="headerlink" title="5th place: passages"></a>5th place: passages</h4><ul><li><strong>Team members:</strong> Bole Ai (Nanjing University), Xiang Long (Beijing University of Posts and Telecommunications), Kaiyuan Li (Beijing University of Posts and Telecommunications), Quan Lin (Huazhong University of Science and Technology), Xiaofan Liu (Beijing University of Posts and Telecommunications), Pengfei Wang (Beijing University of Posts and Telecommunications), Mingdao Wang (Beijing University of Posts and Telecommunications), Zhichao Feng (Beijing University of Posts and Telecommunications), Kun Zhao (Nanjing University)</li><li><strong>Method:</strong> SGC + R-GAT + Finetune</li><li><strong>Test Accuracy:</strong> 0.7381</li></ul><h4 id="6th-place-DeeperBiggerBetter"><a href="#6th-place-DeeperBiggerBetter" class="headerlink" title="6th place: DeeperBiggerBetter"></a>6th place: DeeperBiggerBetter</h4><ul><li><strong>Team members:</strong> Guohao Li (KAUST), Hesham Mostafa (Intel Corporation), Jesus Alejandro Zarzar Torano (KAUST), Sami Abu-El-Haija (USC), Marcel Nassar (Intel Labs), Daniel Cummings (Intel Corporation), Sohil Shah (Intel Corporation), Matthias Mueller (Intel Labs), Bernard Ghanem (KAUST)</li><li><strong>Method:</strong> GNN180M</li><li><strong>Test Accuracy:</strong> 0.7353</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>图神经网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blog迁移</title>
    <link href="/2021/11/08/Blog%E8%BF%81%E7%A7%BB/"/>
    <url>/2021/11/08/Blog%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="如何管理我的Blog"><a href="#如何管理我的Blog" class="headerlink" title="如何管理我的Blog"></a>如何管理我的Blog</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>开始的Blog是在我自己的笔记本上配置的，后来感觉在实验室的时间更多，需要把Blog转移到实验室的主机上。考虑到之后Blog会经常搬家，希望能够找到一种最简单的维护方案，并记录于此。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>自己的方案是github+onedrive。<br>首先分拆功能，github只负责保存hexo生成的html文件，并显示。因此对于作者而言，更值得操心的是markdown文件。显然只要有markdown文件，我们还可以找到其他类似hexo或者更加便捷的工具制作自己的博客。当然markdown文件中利用到的hexo各种插件，则有可能因为新平台不支持而失效，这也是需要提前预警的。写博客最好不要太痴迷外观和插件，否则当初博客多漂亮，迁移一次后就有多丑。<br>言归正传，既然对于作者更重要的东西是markdown，那么只需要同步好本地的工作区就好了。这里使用我一如既往喜欢使用的OneDrive，作为OneNote重度用户，我在某淘上购买了OneDrive的会员，速度相比普通用户会提升很多，使用起来没有问题。将整个Blog文件夹放在OneDrive中进行同步。如此以来，即使更换设备，我只需要在新设备上重新部署hexo工具并安装相应的插件即可。<br>今天，自己的新主机终于到了，这里就记录下操作的过程。</p><h3 id="Blog工作区展示"><a href="#Blog工作区展示" class="headerlink" title="Blog工作区展示"></a>Blog工作区展示</h3><p><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211108214325.png" alt="工作区"><br>如图，<strong> Blog主机迁移 </strong>中就是每次迁移主机，一些需要安装的软件包，如node.js，git安装包以及迁移步骤的markdown说明。</p><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>因为win10上安装hexo需要使用node.js。因此如前所述，我将安装包放在了 <strong> Blog主机迁移 </strong>文件夹中。双击安装node.js。<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211108214740.png" alt="node.js安装测试"><br>安装完后，进入命令行测试，安装成功。</p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>git 是hexo用于和github交互的依赖工具，因此也要安装。同样放在<strong> Blog主机迁移 </strong>文件夹中，双击安装。<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211108215005.png" alt="git安装测试"></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>（可选）设定npm源，用于加速<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><br>安装hexo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g<br></code></pre></td></tr></table></figure></p><h3 id="配置git账户"><a href="#配置git账户" class="headerlink" title="配置git账户"></a>配置git账户</h3><p>设置git全局的用户名和邮箱<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config -l<br>$ git config --global user.name &lt;github account username&gt;<br>$ git config --global user.emial &lt;github account email&gt;<br></code></pre></td></tr></table></figure><br>生成公钥，上传到github<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen<br></code></pre></td></tr></table></figure></p><p>完成上述步骤后，测试git是否可以链接github<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -T git@github.com<br></code></pre></td></tr></table></figure></p><h3 id="同步hexo"><a href="#同步hexo" class="headerlink" title="同步hexo"></a>同步hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g -d<br></code></pre></td></tr></table></figure><p>至此，同步成功。如有问题，欢迎留言。<br>如果存在 timeout，可以重试几次。<br>或者可以尝试在_config.yml文件中修改ropo仓库链接为ssh协议<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211109090449.png" alt="_config.yml"><br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211109090517.png" alt="hexo同步成功"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>今天学习了下，将博客中的图片存放在图床服务上。<br>我采用的方案是vscode+picgo+阿里云OSS。<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211108213910.png" alt="picgo快捷键"><br>当然，图片也可以由hexo来管理，每次生成文章按照hexo的规则放置在一个文件夹中，距离可以参考<sup><a href="#fn_2" id="reffn_2">2</a></sup></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote id="fn_1"><sup>1</sup>. <a href="https://blog.csdn.net/Aealen/article/details/105613567">更多hexo避坑指南</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://hexo.io/zh-cn/docs/asset-folders">hexo资源文件夹</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>博客使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从valine转向waline</title>
    <link href="/2021/10/31/%E4%BB%8Evaline%E8%BD%AC%E5%90%91waline/"/>
    <url>/2021/10/31/%E4%BB%8Evaline%E8%BD%AC%E5%90%91waline/</url>
    
    <content type="html"><![CDATA[<p>valine真的很舒服，因为自己深受注册登陆的烦恼，觉得根本不是多么重要的一个网页也需要获取我特意注册一个账户才能使用非常麻烦。valine可以把选择权交给用户，并且留下联系方式的过程也非常简单，这一点是我第一次看到valine，就选择其作为博客评论的选择，并为其特意设计了邮件通知系统。然而转头就发现了关于valine的安全性问题，具体参考文章<sup><a href="#fn_1" id="reffn_1">1</a></sup>。我并不是做前端的，对其中的一些概念并不了解，但是也能看出valine可能没有那么安全。基于此，我选择了在没有太深入绑定之前，转到waline的。</p><h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><p>我理解waline相比于valine，将评论功能拆分为两部分，让服务不直接接触存储，从而避免用户通过js命令行读写内存造成安全性问题。</p><ul><li>vercel上部署服务，通过ServerURL进行内存读写，也是评论功能的主要实现</li><li>leanCloud上进行数据的保存，在构建vercel时提供leanCloud的appID, appKey, masterKey信息。即对于vercel而言，leanCloud也是一个服务。</li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>过程参考<sup><a href="#fn_2" id="reffn_2">2</a></sup>: 部署leanCloud, 部署vercel, hexo g -d重构…<br>vercel的部署参考<sup><a href="#fn_2" id="reffn_2">2</a></sup>，过程并不复杂。要注意github的邮箱如果之前勾选了保密，注意暂时先点掉，否则会出现vercel拷贝github上的reposity库时不成功的问题。说多了都是泪…</p><h3 id="更多waline功能3"><a href="#更多waline功能3" class="headerlink" title="更多waline功能3"></a>更多waline功能<sup><a href="#fn_3" id="reffn_3">3</a></sup></h3><ol><li>设置微信通知<br>主要是使用Server酱，Server酱类似与一个公共的服务, ServerKey写入vercel的环境变量中</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote id="fn_1"><sup>1</sup>. <a href="https://imnerd.org/valine-may-not-so-good.html">基于Serverless的valine可能没有那么香</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://waline.js.org/guide/get-started.html#html-%E5%BC%95%E5%85%A5-%E5%AE%A2%E6%88%B7%E7%AB%AF">waline搭建</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. <a href="https://zzz.zywvvd.com/notes/hexo/theme/fluid/fluid-waline/fluid-waline/">更多waline功能</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>博客使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo和Github搭建公开文档（姑且称之为博客吧）</title>
    <link href="/2021/10/30/Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E5%85%AC%E5%BC%80%E6%96%87%E6%A1%A3%EF%BC%88%E5%A7%91%E4%B8%94%E7%A7%B0%E4%B9%8B%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%90%A7%EF%BC%89/"/>
    <url>/2021/10/30/Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E5%85%AC%E5%BC%80%E6%96%87%E6%A1%A3%EF%BC%88%E5%A7%91%E4%B8%94%E7%A7%B0%E4%B9%8B%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%90%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>关于创建自己的博客，本科时就使用服务器和wordpress构建过好多次，无奈维护起来过于复杂，很多时候没有写文章的时间还不如维护的时间多。这次心血来潮，也明白了凡事由浅入深，写博客更主要的目的还是想整理一些系统的思考、学习。因此选择了维护和搭建更简单的github+hexo的方案。虽然是静态页面，但是后端通过markdown书写的方式，十分方便自己做一些笔记用。废话不多说，接下来就简单介绍下本次搭建的过程。</p><h3 id="在Github上创建一个reposity"><a href="#在Github上创建一个reposity" class="headerlink" title="在Github上创建一个reposity"></a>在Github上创建一个reposity</h3><p>reposity是一个项目仓库，就是我们平时fork的项目，简单说就是个高级点的文件夹</p><p>注意以下几个点：</p><ol><li><p>一定是Public，后面才能被公网上访问</p></li><li><p>创建完后，注意在setting中设置一下，才能使用username.github.io访问这个reposity</p></li><li><p>为了方便本地生成静态页面，后期都是git clone到本地，使用git进行维护</p></li></ol><h3 id="为博客选择一个模板"><a href="#为博客选择一个模板" class="headerlink" title="为博客选择一个模板"></a>为博客选择一个模板</h3><p>为了省去博客网页的维护，将主要精力放在内容的书写上。“博客生成器”，能够将文本文档有机的整合为html语言。github支持jekyll，类似的还有hexo，hugo,pelican等。</p><p>但是，由于jekyll对win10支持不够友好，一凡折腾之后还是选择了hexo。殊途同归。</p><p>这里给几个模板的例子：</p><ol><li><p><a href="https://zkqiang.cn/">https://zkqiang.cn/</a><br>很漂亮，但是首页的大图容易让人失去写作的专注。我还是想更多聚焦在内容的书写、管理和浏览上。但是看了一圈，这个是最合适的了，所以也是写本文时选用的模板。</p></li><li><p><a href="https://ares-x.com/categories/">https://ares-x.com/categories/</a><br>该方案适合随笔较多。Archives(归档)、Categories(类别)、Tags(标签)字体更小，能够看到更多内容。但是页面美观上就少了很多可能，实在遗憾。</p></li><li><p><a href="https://chhzh123.github.io/blogs/">https://chhzh123.github.io/blogs/</a><br>一个中山大学去了Cornell读PHD的大佬，博客也是非常棒，特别是最后的留言功能！各位如果看到本文由任何问题，也欢迎在下面留言。</p></li></ol><h3 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h3><ol><li><p>(可跳过)设定npm源，不然后面npm install很慢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure></li><li><p>创建一个Blog文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkdir Blog<br>$ <span class="hljs-built_in">cd</span> Blog<br>$ hexo init<br>$ npm install<br></code></pre></td></tr></table></figure><p>结束后，能够看到Blog下面多了一堆文档</p></li><li><p>本地生成页面查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo -s<br></code></pre></td></tr></table></figure><p>然后在浏览器访问返回的链接</p></li><li><p>配置本地git账户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config -l<br>$ git config --global user.name &lt;github account username&gt;<br>$ git config --global user.emial &lt;github account email&gt;<br></code></pre></td></tr></table></figure><p>关于git，后面有可能遇到email和密码不能登陆的问题，问题不大，遇到了多百度，也可以在下面留言。这里主要是github对用户email公开的隐私问题以及密码登陆的安全性问题的限制。</p></li><li><p>链接本地文件和远程仓库<br>首先修改_config.yml文件，设定为自己reposity链接和branch分支。这里注意branch分支，github后来更改为mian了，不再是master。<br>然后执行下述命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g -d<br></code></pre></td></tr></table></figure><p>该命令过后，就相当于git push到了远程仓库。但是需要github反应一会，也可能是浏览器的页面缓存还没有失效，需要等待一会才能看到新的页面。</p></li><li><p>创建新页面<br>具体可以参考hexo官方手册</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>创建draft页面（默认先不上传），再将draft发布为post</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new draft &lt;title&gt;<br>$ hexo publish draft &lt;title&gt;<br></code></pre></td></tr></table></figure><p>创建page页面。page就是类似categories和tags平级的页面，可以汇总新类型页面，通过形如<code>https://erodata.github.io/categories/</code> 访问到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page demo<br></code></pre></td></tr></table></figure><p>如此，在source文件夹下会创建一个demo文件夹，内部有一个index.md文件。修改该index.md文件就可以在该页面制作一个你想要展示的demo网页。<br>具体可以进一步参考</p></li><li><p>生成器<br>生成文件，使用 Hexo 生成静态文件快速而且简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure></li><li><p>valine邮件提醒测试<br>主要参考链接<sup><a href="#fn_6" id="reffn_6">6</a></sup>。所谓邮件提醒，就是后台收到评论后，登陆一个邮箱发送通知给作者。因此需要一个发送邮箱，一个接收邮箱。发送邮箱需要提供密码，为了安全起见，我使用的是QQ邮箱向163邮箱通知。其中，QQ邮箱是我开的小号。最后，云引擎并不需要绑定一个域名，我测试也是成功的。</p></li></ol><ul><li>监视文件变动<br>Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate --watch<br></code></pre></td></tr></table></figure></li><li>完成后部署<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate --deploy <span class="hljs-comment"># 也可以简写乘 hexo g -d</span><br>(或)$ hexo deploy --generate <span class="hljs-comment"># 简写为hexo d -g</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><ol><li><p>Latex数学公式 测试</p><script type="math/tex; mode=display">E=mc^2</script><script type="math/tex; mode=display">\frac{\partial P(x, y)}{\partial x} = e^y\pi</script></li><li><p>Mermaid流程图 测试</p><pre><code class=" mermaid">classDiagramClass01 &lt;|-- AveryLongClass : CoolClass03 *-- Class04Class05 o-- Class06Class07 .. Class08Class09 --&gt; C2 : Where am i?Class09 --* C3Class09 --|&gt; Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 &lt;--&gt; C2: Cool label</code></pre></li><li>OneDrive同步<br>测试</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote id="fn_1"><sup>1</sup>. <a href="https://www.bilibili.com/video/BV1at4y1D7rr?from=search&amp;seid=9483946196476379073&amp;spm_id_from=333.337.0.0">hexo搭建个人博客</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. <a href="https://hexo.io/zh-cn/docs/setup">hexo官方手册</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><blockquote id="fn_3"><sup>3</sup>. <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid Github</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a></blockquote><blockquote id="fn_4"><sup>4</sup>. <a href="https://valine.js.org/hexo.html">留言功能 Valine</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a></blockquote><blockquote id="fn_5"><sup>5</sup>. <a href="https://hexo.io/themes/">更多hexo主题</a><a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a></blockquote><blockquote id="fn_6"><sup>6</sup>. <a href="https://dreamhomes.top/posts/202102021138/">valine评论邮件提醒</a><a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a></blockquote><blockquote id="fn_7"><sup>7</sup>. <a href="https://markdown.com.cn/extended-syntax/footnotes.html">MarkDown官方手册</a><a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a></blockquote><blockquote id="fn_8"><sup>8</sup>. <a href="https://hexo.fluid-dev.com/posts/fluid-write/">Fluid作者的example博客</a><a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a></blockquote><blockquote id="fn_9"><sup>9</sup>. <a href="https://oakland.github.io/2016/05/02/hexo-%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E7%AF%87%E6%96%B0%E7%9A%84post/">oakland的博客</a><a href="#reffn_9" title="Jump back to footnote [9] in the text."> &#8617;</a></blockquote><blockquote id="fn_10"><sup>10</sup>. <a href="https://xring.info/2018/hexo-category-and-tag-page.html">xring的博客</a><a href="#reffn_10" title="Jump back to footnote [10] in the text."> &#8617;</a></blockquote>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>博客使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
