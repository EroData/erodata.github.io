<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>tmux-vscode-远程开发大杀器</title>
    <link href="/2022/01/06/tmux-vscode-%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E5%A4%A7%E6%9D%80%E5%99%A8/"/>
    <url>/2022/01/06/tmux-vscode-%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E5%A4%A7%E6%9D%80%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>随着实习和项目经历的丰富，对于远程连接+远程编程逐渐熟练。远程连接意味着计算和存储资源都在远端，意味着在服务器上进行开发。好的工作工具会让开发事半功倍。<br>自己最早接触的是screen，一般只能保存部分工作现场，解决最早电脑断网，希望服务器上的命令不会跟随ssh断开而shut down的问题。screen的能力还是有限的，特别是要开多个session的时候，感觉非常乱。</p><p>tmux算是screen进阶版本，功能更加强大，也更有条理。相比于screen，tmux要记住的命令当然也多，但是用不到的可以先不管，慢慢来！<br>首先，我们先理清tmux使用过程中的一些概念，这有助于我们命令每一个窗口都意味着什么。<br>在运行tmux后，会有启动一个tmux server来管理tmux的sessions,注意</p><ol><li>一个机器上只开了一个tmux server管理一切；</li><li>一个tmux server管理多个session，每个session我们都会赋予他一个名字</li><li>一个tmux session可以有多个window,类似终端上的多个标签页</li><li>一个windows上可以有多个pane，即分屏<br>session可翻译为“会话”，window可翻译为“窗口”，pane可翻译为“窗格”</li></ol><h2 id="使用">使用</h2><h3 id="快速上手">快速上手</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new-session -s code // 创建一个名为code的终端<br>$ tmux ls // 查看目前开启的session<br>// ctrl-b d // 退出但是不删除code session, 也可以直接关闭xshell。这个突然断电关机也不怕，保命神器！<br>$ tmux a -t code // 重新连接上去！<br></code></pre></td></tr></table></figure><h3 id="tmux">tmux</h3><ol><li>关于 session</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new-session -s code // 创建一个session<br>// ctrl-b d // 退出但是不删除这个session<br>// ctrl-b :kill-session // 删除当前session<br>// ctrl-b :kill-server // 停止server，即删除所有session<br>$ tmux a -t code // 重新连上ssession<br></code></pre></td></tr></table></figure><ol start="2"><li><p>关于复制<br>xshell+tmux，需要先按住shift，然后选中文档再右键，才有复制和粘贴的选项</p></li><li><p>关于pane</p></li></ol><ul><li>xshell上可以通过右键的方式选择vertical/horizontal split的方式生成其他pane；</li><li>再通过左键点击，进入不同pane输入命令；</li><li>通过拖动边界还可以调整pane的大小<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211122155826.png" alt=""></li></ul><h3 id="vscode">vscode</h3><p>vscode上使用remote-SSH工具配置HostName, Port, User即可远程连接进行开发。如果有跳板机，可以通过下图的<code>ProxyCommand</code>进行跳转。<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211122155424.png" alt=""></p><h2 id="tmux-技巧">tmux 技巧</h2><h3 id="tmux的command-prompt">tmux的command-prompt</h3><p>tmux的快捷键和命令是对应的，我们也可以使用键入命令来实现某个功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 按下ctrl-b : 就可以进入command-prompt窗口<br>// 然后输入对应命令就可以了<br></code></pre></td></tr></table></figure><h3 id="tmux-快捷键的帮助">tmux 快捷键的帮助</h3><p>tmux的每个快捷键由send-prefix和bind-key组成<br>send-prefix 是固定的，就是 ctrl-b<br>bing-key是每个功能的关键词，想不起来的时候，可以通过如下命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 按下ctrl-b ?<br></code></pre></td></tr></table></figure><h3 id="鼠标模式">鼠标模式</h3><p>打开鼠标模式，则可以通过鼠标拖动pane的边框；当然, 鼠标模式下的拷贝粘贴需要按住shift</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ctrl+b : <span class="hljs-built_in">set</span> mouse-mode on // 老版本打开鼠标模式<br>$ ctrl+b : <span class="hljs-built_in">set</span> -g mouse on // 新版本打开鼠标模式<br></code></pre></td></tr></table></figure><p>鼠标模式下的快捷特性如下：</p><ul><li>开启用鼠标拖动调节pane的大小（拖动位置是pane之间的分隔线）</li><li>开启用鼠标点击pane来激活该pane</li><li>开启用鼠标点击来切换活动window（点击位置是状态栏的窗口名称）</li><li>开启window/pane里面的鼠标支持（也即可以用鼠标滚轮回滚显示窗口内容，此时还可以用鼠标选取文本）</li></ul><h3 id="重新绑定-send-prefix">重新绑定 send-prefix</h3><p>也可以更换快捷键的tmux-prefix中的 ctrl-b, 这个也在tmux的配置文件中(.tmux.conf)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">unbind C-b<br><span class="hljs-built_in">set</span> -g prefix C-a<br></code></pre></td></tr></table></figure><h3 id="tmux-显示时间和快速切换快捷键">tmux 显示时间和快速切换快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ 按下 ctrl-b t, 会在当前window的当前pane显示当前时间<br>$ 按下 ctrl-b q, 每一个pane都会出现一个数字，按下想要切换的pane数字，就可以切换到对应的pane<br>// 关于切换pane，实际上用鼠标左键直接点击也可以..而且右键也有很多功能，如纵切window为两个pane<br><br><br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变分自编码器(VAEs)</title>
    <link href="/2021/11/17/%E5%8F%98%E5%88%86%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8-VAEs/"/>
    <url>/2021/11/17/%E5%8F%98%E5%88%86%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8-VAEs/</url>
    
    <content type="html"><![CDATA[<h2 id="VAEs简介">VAEs简介</h2><p>变分自编码器（Variational auto-encoder, VAE）是一类重要的生成模型（generative model）, 于2013年由P.Kingma和Welling提出。2016年Carneie/UCB的Carl Doersch联合团队写了一篇关于VAEs的tutorial，算是详细地介绍了VAEs。完成本文前，我也是细致得读了一遍。<br>首先，VAEs是一个生成式的模型。以Minist数据为例，每个$X$代表一个28*28的图像，也就是784维空间上的一个点。在这个空间上，有些是手写数字，有些则不是。因此存在一个概率分布$P(X)$。直观上去想，$P(X)$小表示这个图像更不像是一个手写数字，$P(X)$大则表示更像一个标准的手写数字。因此如果我们站在上帝视角有了数据集X的分布$P(X)$，我们就不需要机器学习什么事了。因为给我任意一个$X$，我可以计算$P(X)$得到他是一个手写数字的概率。</p><p>以上可能只解决了无监督情况下，或者说是“是否是手写数字”的问题，并没有解决常见的Minist问题中数字是几的问题。这个实际上在CVAE中解决。从生成模型的角度看，后一类问题，我们需要知道数据集$(X,Y)$上的分布，即$P(X,Y)$。</p><p>VAEs作为一类生成式的模型，其核心想法如下：将一个随机变量z通过$f_\theta(z)$ 映射为$X$，把对$X$分布$P(X)$的学习，转化为对 $f_\theta(·)$的学习。$f_\theta(·)$也就是我们需要的模型。有一些概率基础的同学，应该能够明白这个过程就是一个概率密度函数的转换。下图作者给了一个简单的二维高斯分布映射到一个圆上的过程。</p><p><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211117162230.png" alt=""></p><p>当然，除了VAEs，还有一个重要的生成模型GANs。后面有机会，再整理其原理。</p><p><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211117161809.png" alt=""></p><p>上图很好的表示了VAE的思路，我们选取了数学上比较友好的高斯函数$N(0,1)$用于采样z，每个z通过一个deterministic function $f_\theta(·)$算出一个$X$。z计算出X的过程，就是我们decoder模型需要做的事情。</p><h2 id="VAEs模型的理论推导">VAEs模型的理论推导</h2><p>上面我们取用了deterministic function来表示了z与X的映射关系，实际上为了表示X和z之间的一种不确定关系，也为了数学上的便利（tutorial上自己写的…），我们这里替换为条件概率的形式。最大化下面的式子：<br>$$ P(X)=\int P(X|z;\theta)P(z)dz$$<br>如果用$P_{gt}(X)$表示真实X的分布，那么上面式子的最大值就是$P_{gt}(X)$</p><p>正如上面的替换表示了z,X的一种不确定关系，如果我们直接优化上面的式子，那么必然很多$P(X|z; \theta)$应该是0。为了进一步缩小z的范围，我们需要一个函数$Q(z|X)$来确定z。如此一来计算$E_{z~Q}P(X|z)$就更方便了。</p><p>$Q(z|X)$就是我们encoder模型要做的事情，它当然是对真实情况$P(z|X)$的拟合。这个拟合越好，模型的效果当然越好。因此我们也需要优化这两个分布的距离。概率论中一般使用KL散度去度量两个分布的距离。即下面的式子：<br>$$D[Q(z|X)||P(z|X)]=E_{z\sim Q}[logQ(z|X)-logP(z|X)]$$</p><p>通过对上式，应用条件概率公式，我们可以把最初的优化目标$P(X)$和encoder部分的优化目标$D[Q(z|X)||P(z|X)]$放一起，就有下面推导的结果<br>$$D[Q(z|X)||P(z|X)] = E_{z\sim Q}[logQ(z)-logP(X|z)-logP(z)] + logP(X)$$<br>$$logP(X)-D[Q(z|X)||P(z|X)] = E_{z\sim Q}[logP(X|z)] - D[Q(z|X)||P(z)]$$</p><p>该推导结果的等式左侧是实际意义，右侧是损失函数的计算公式，也是我们经常在论文中看到的。<br>ps. 上面是为了便于理解，更多观点还是希望优化$logP(X)$, 把$D[Q(z|X)||P(z|X)]$放到等式右侧，由于KL散度非负，因此可以放缩成一个下界的形式。依然是一样的损失函数。更多可以参考知乎文章[^2]</p><p>关于损失函数的具体计算，第二项$D[Q(z|X)||P(z)]$被当作两个高斯函数求解，第一项外层的期望并没有求，而是对每个$X$只采样一个z, 通过多步训练去优化。</p><p>PyTorch的实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loss_function</span> (<span class="hljs-params">recon_x, x, mu, log_var</span>):</span><br>    BCE = F.binary_cross_entropy(recon_x, x, reduction=<span class="hljs-string">&#x27;sum&#x27;</span>)<br>    KLD = -<span class="hljs-number">0.5</span> * th.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span> + log_var - mu.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>) - log_var.exp())<br>    <span class="hljs-keyword">return</span> BCE + KLD, BCE, KLD<br></code></pre></td></tr></table></figure><h2 id="参考内容">参考内容</h2><p>[^1]: <a href="https://arxiv.org/pdf/1606.05908.pdf">Tutorial on Variational Autoencoders</a><br>[^2]: <a href="https://zhuanlan.zhihu.com/p/25401928">知乎文章</a><br>[^3]: <a href="https://zhum.in/blog/tutorial/hexo%E4%B8%8B%E6%B8%B2%E6%9F%93mathjax%E9%97%AE%E9%A2%98.html">写作本文遇到的行内公式的坑</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>变分自编码器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>变分自编码器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-基本数据结构-使用指南</title>
    <link href="/2021/11/12/Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2021/11/12/Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>从8月份开始陆陆续续用Java在leetcode上刷了350+的题目，算是把一些基本的Java数据结构用过来一边了。想起上半年实习的时候还一点Java不会，渐渐算是熟悉了Java语言。</p><p>一些比较深入的redis/springboot，只是在公司的时候了解过一些，没有这方面的项目，因此这里就不涉及了。这些东西感觉有了Java的语感，就是API的使用问题，到时候再学习。这里主要集中整理基本数据结构的使用。</p><h2 id="比较常用的数据结构：">比较常用的数据结构：</h2><p>int, long, char是基本类型，Integer, Long, Character, String等是类。类的特征就是他可以是null的。</p><p>一般情况下,JDK1.5/Java 5有一个新特性就是支持自动装包/解包，意思是int &lt;-&gt; Integer的转换可以隐式的进行。一些情况下，如int[] &lt;-&gt; List<Integer> 就需要自己调用函数了。</p><h2 id="一些Trick">一些Trick</h2><ol><li>定义数组并填充数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++) &#123;<br>    Arrays.fill(dp[i], -<span class="hljs-number">1</span>); <span class="hljs-comment">// 实现逐行填充dp内容为-1</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>List只是接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList(); <span class="hljs-comment">// 随机读取是O(1)</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList(); <span class="hljs-comment">// 随机读取是O(n)</span><br></code></pre></td></tr></table></figure><ol start="3"><li>List和Arrar互相转化</li></ol><ul><li>Array转List</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] s = <span class="hljs-keyword">new</span> String[] &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;;<br>List&lt;String&gt; list = Arrays.asList(s); <span class="hljs-comment">// 值得注意的是，s的修改会直接影响到list，因此为了避免意外</span><br><span class="hljs-comment">// 最好采取下面的方式</span><br>List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>);<br><span class="hljs-comment">// 或者</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList(Arrays.asList(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;bc&quot;</span>))<br></code></pre></td></tr></table></figure><ul><li>List转Array</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] dest = list.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 一是这里dest和list的空间不同，一个修改不影响另一个</span><br><span class="hljs-comment">// 二是 new String[0]这里不仅指定了返回的类型，还指定了空间；写为0，则会自动按照list大小重新开辟空间。写0和list大小都可以，但是不能省略</span><br></code></pre></td></tr></table></figure><ol start="4"><li>int[] 转 List<Integer></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.stream(ints).boxed().collect(Collectors.toList());<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Arrays.stream(ints) 是生成了intStream流，流中元素为int而不是Integer，因此需要使用boxed()打包</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">** 区别于Arrays.asList(ints).stream()则是在asList()中做了int到Integer的转化，出来的是Integer Stream流。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="常用模板">常用模板</h2><h3 id="二分法">二分法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 二分法可以是分而治之的思想，也可以是删除法的思想</span><br><span class="hljs-comment">// leetcode: 162.寻找峰值</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> solution2(nums);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">solution2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> b = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (a &lt; b) &#123;<br>            <span class="hljs-keyword">int</span> mid = (a+b) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[mid+<span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 由于mid总是靠左，mid+1总是不会越界的</span><br>                a = mid+<span class="hljs-number">1</span>; <span class="hljs-comment">// 保证新的区间[mid+1, b] nums[b] &gt; nums[b+1], 且nums[mid+1] &gt; nums[mid], 即还是有峰值在该区间</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                b = mid; <span class="hljs-comment">// 保证新的区间[a, mid] nums[a] &gt; nums[a-1], 且 nums[mid] &gt;= nums[mid+1], 即还是有峰值在该区间</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最后区间为[a, a] 有，nums[a] &gt; nums[a+1] 且 nums[a] &gt; nums[a-1], 因此a位置处就是峰值</span><br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="bfs-广度优先">bfs, 广度优先</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode: 102. 二叉树的层序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        <span class="hljs-comment">// 所谓层序遍历，就是bfs搜索过程中的queue中添加的顺序</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">int</span> num = queue.size();<br>            List&lt;Integer&gt; clist = <span class="hljs-keyword">new</span> ArrayList();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;num; i++) &#123;<br>                TreeNode node = queue.poll();<br>                clist.add(node.val);<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) queue.add(node.right);<br>            &#125;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList(clist));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dfs-深度优先">dfs, 深度优先</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode: 94. 二叉树的中序遍历</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">// 中序遍历，应该把根节点放在中间</span><br>        <span class="hljs-comment">// 递归到每个节点时候，应该先dfs左做点，然后放入本节点，然后调用右节点</span><br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.left);<br>        res.add(root.val);<br>        dfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希表">哈希表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode: 1. 两数之和</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-comment">// solution1() 双指针不能做，数组无序，题目要求返回索引，因此如果双指针，必然要多一些空间或者时间，用于找到对应的索引;</span><br>        <span class="hljs-keyword">return</span> solution2(nums, target);<br>        <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] solution2(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-comment">// HashMap()解法</span><br>        Map&lt;Integer, Integer&gt; valueIndex = <span class="hljs-keyword">new</span> HashMap();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (valueIndex.containsKey(target - nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, valueIndex.get(target - nums[i])&#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                valueIndex.put(nums[i], i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优先队列">优先队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Integer&gt; com = <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer n1, Integer n2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Integer.compare(n1, n2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意Comparator的写法，重写compare函数，注意可以使用Integer.compare(Integer, Integer), String::compareTo(String)函数。<br>可以有效避免写法上的复杂，以及Integer越界的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode: 215.数组中的第k个最大元素</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> solution3(nums, k);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">solution3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用小顶堆</span><br>        PriorityQueue&lt;Integer&gt; pqueue = <span class="hljs-keyword">new</span> PriorityQueue(<span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer n1, Integer n2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(n1, n2);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++) &#123;<br>            pqueue.add(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=k; i&lt;nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= pqueue.peek()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pqueue.poll();<br>                pqueue.add(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pqueue.poll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双端队列">双端队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode: 229. 滑动窗口最大值</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">return</span> solution1(nums, k);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] solution1(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-comment">// 更好的方式是使用单调栈, 使用双端队列实现; 因为每个数字只会进入一次出来一次，因此处理每个窗口的平均时间复杂度是O(1)的</span><br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n-k+<span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i]) &#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(i);<br>        &#125;<br>        res[<span class="hljs-number">0</span>] = nums[deque.peekFirst()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=k; i&lt;nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (deque.peekFirst() &lt;= i-k) &#123;<br>                deque.pollFirst();<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i]) &#123;<br>                deque.pollLast();<br>            &#125;<br>            deque.offerLast(i);<br>            res[i-k+<span class="hljs-number">1</span>] = nums[deque.peekFirst()];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态规划">动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// leetcode: 10.正则表达式匹配</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] dp; <span class="hljs-comment">// 1表示true， -1表示false, 0表示还没有搜索到</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> solution1(s, p);<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">solution1</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = s.length();<br>        <span class="hljs-keyword">int</span> n = p.length();<br><br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// 其他f[0][j]和f[i][0]都取默认值false</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (i!=<span class="hljs-number">0</span> &amp;&amp; (p.charAt(j-<span class="hljs-number">2</span>)==<span class="hljs-string">&#x27;.&#x27;</span> || s.charAt(i-<span class="hljs-number">1</span>)==p.charAt(j-<span class="hljs-number">2</span>))) &#123;<br>                        dp[i][j] = dp[i][j - <span class="hljs-number">2</span>] || dp[i - <span class="hljs-number">1</span>][j];<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i][j] = dp[i][j - <span class="hljs-number">2</span>];<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (i!=<span class="hljs-number">0</span> &amp;&amp; (p.charAt(j-<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;.&#x27;</span> || s.charAt(i-<span class="hljs-number">1</span>)==p.charAt(j-<span class="hljs-number">1</span>))) &#123;<br>                        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i][j] = <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为OpenMP学习铺路</title>
    <link href="/2021/11/11/%E4%B8%BAOpenMP%E5%AD%A6%E4%B9%A0%E9%93%BA%E8%B7%AF/"/>
    <url>/2021/11/11/%E4%B8%BAOpenMP%E5%AD%A6%E4%B9%A0%E9%93%BA%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>OpenMP是一种并行程序设计语言，调用多个内核完成任务。根据并行机体系结构的不同、访存模型的不同，并行程序设计模型也有所不同。</p><p>中科院计算机网络信息中心（超级计算中心）提供了一份OpenMP并行编程的分享[^4]。</p><h2 id="连接并行的硬件基础">连接并行的硬件基础</h2><p>并行的基础不再是单核上虚拟多线程，利用计算和io的交替充分利用cpu的时间片，而是现代多cpu/多core/超线程技术下的真并行方案。由于现代并行计算任务往往伴随大数据，因此即使计算任务划分开，每个thread上仍然会有访问memory的冲突。NUMA结构解决了早期SMP体系中前端总线FSB上的瓶颈问题。</p><p><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111164629.png" alt=""></p><h4 id="不同的并行机体系结构以及通信机制适用不用的并行编程模型">不同的并行机体系结构以及通信机制适用不用的并行编程模型</h4><p>主要有两类：</p><ul><li>SMP: 共享内存并行机</li><li>DSM: 分布共享存储并行机<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111161711.png" alt=""></li></ul><h4 id="访存模型">访存模型</h4><ul><li>多处理器（单个地址空间）， NUMA也是单个地址空间</li><li>多计算机（多个地址空间），通过网络通信连接<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111162022.png" alt=""></li></ul><h4 id="OpenMP-API">OpenMP API</h4><p><a href="https://www.openmp.org/specifications/">OpenMP 官网</a><br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111170516.png" alt=""></p><p><a href="https://www.openmp.org/wp-content/uploads/OpenMPRefCard-5.1-web.pdf">OpenMP 5.1 API cheating paper</a><br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111170447.png" alt=""></p><p><a href="https://hpc.llnl.gov/tuts/openMP/#Abstract">OpenMP tutorial</a><br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111170622.png" alt=""></p><p><a href="https://man7.org/linux/man-pages/man3/numa.3.html">NUMA manual page</a><br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211111170711.png" alt="20211111170711"></p><h2 id="参考资料">参考资料</h2><p>[^1]: OpenMP 官方网站：<a href="https://www.openmp.org/">OpenMp.org</a>。在此可以找到API定义，常见问题，报告，讨论，多媒体，日程，会员应用等<br>[^2]: <a href="https://hpc.llnl.gov/">劳伦斯利弗莫尔国家实验室(Lawrence Livermore National Laboratory, LLNL)</a>,在此搜索OpenMP，可以找到openMP的tutorial[^3]<br>[^3]: <a href="https://hpc.llnl.gov/tuts/openMP/#Abstract">OpenMP’s tutorial</a><br>[^4]: <a href="https://scc.ustc.edu.cn/zlsc/cxyy/200910/W020121113517997951933.pdf">OpenMP并行编程</a></p>]]></content>
    
    
    <categories>
      
      <category>并行编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并行编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OGB-LSC KDD Cup 2021</title>
    <link href="/2021/11/10/OGB-LSC-KDD-Cup-2021/"/>
    <url>/2021/11/10/OGB-LSC-KDD-Cup-2021/</url>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>KDD Cup 全称为国际知识发现和数据挖掘竞赛，自1997年开始，由 ACM 协会 SIGKDD 分会每年举办一次，目前是全球数据挖掘领域最有影响力的赛事，其所设比赛题目具有相当高的实际意义和商业价值。多年来，该赛事每年都吸引着众多世界顶级的 AI 研究机构与企业的参与，并且催生了大量的经典比赛和经典算法。</p><p>今年，KDD Cup 2021 首次与斯坦福大学图神经网络权威 Jure Leskovec 教授领导 Open Graph Benchmark（OGB）团队合作，联合举办第一届 OGB Large-Scale Challenge，共有500余个来自全球各地的队伍参赛。</p><h2 id="KDD-Cup-2021">KDD Cup 2021</h2><p>KDD Cup 2021分为三个赛道：MAG240M-LSC track, WikiKG90M-LSC track, PCQM4M-LSC track。其中MAG240M-LSC比赛使用了来自Microsoft Academic Graph的学术异质图，其中有三类关系：cites(between 2 paper nodes), writes(between author node and paper node), and affiliated with(between author node and instutition node)。涉及总共121M篇论文，122M个作者，26K个机构。</p><p>比赛中使用至2018年之前的论文作为训练集，2019年作为验证集，2020年作为测试集。</p><p><strong>ps.</strong></p><ol><li><p>由于自己在准备的比赛和node classification相关，故本文主要整理MAG240M-LSC的成果。</p></li><li><p>相比于直接看论文，这些比赛中使用的方法往往是真正前沿且可复现的方法。一路看过来，其论文更加言简意赅，并且开源所有代码。无论是初学者，还是业内人士都能快速捕获最新进展。</p></li></ol><h2 id="Winners">Winners</h2><h4 id="1st-place-BD-PGL">1st place: BD-PGL</h4><ul><li><strong>Team members:</strong> Yunsheng Shi (Baidu), Zhengjie Huang (Baidu), Weibin Li (Baidu), Weiyue Su (Baidu), Shikun Feng (Baidu)</li><li><strong>Method:</strong> R-UNIMP</li><li><strong>Test Accuracy:</strong> 0.7549</li></ul><h4 id="2nd-place-Academic">2nd place: Academic</h4><ul><li>** Team members:** Petar Velickovic (DeepMind), Peter Battaglia (DeepMind), Jonathan Godwin (DeepMind), Alvaro Sanchez (DeepMind), David Budden (DeepMind), Shantanu Thakoor (DeepMind), Jacklynn Stott (DeepMind), Ravichandra Addanki (DeepMind), Thomas Keck (DeepMind), Andreea Deac (DeepMind)</li><li>** Method: ** MPNN Ensemble with BGRL fine-tuning</li><li>** Test Accuracy: ** 0.7519</li></ul><h4 id="3rd-place-Synerise-AI">3rd place: Synerise AI</h4><ul><li>** Team members:** Michal Daniluk (Synerise), Jacek Dabrowski (Synerise), Konrad Goluchowski (Synerise), Barbara Rychalska (Warsaw University of Technology/Synerise)</li><li>** Method: ** Cleora + EMDE</li><li>** Test Accuracy: ** 0.7460</li></ul><h2 id="Runner-ups">Runner-ups</h2><h4 id="4th-place-Topology-mag">4th place: Topology_mag</h4><ul><li><strong>Team members:</strong> Qiuying Peng (OPPO Research), Wencai Cao (OPPO Research), Zheng Pan (OPPO Research)</li><li><strong>Method:</strong> MPLP + finetune (40 ensemble)</li><li><strong>Test Accuracy:</strong> 0.7447</li></ul><h4 id="5th-place-passages">5th place: passages</h4><ul><li><strong>Team members:</strong> Bole Ai (Nanjing University), Xiang Long (Beijing University of Posts and Telecommunications), Kaiyuan Li (Beijing University of Posts and Telecommunications), Quan Lin (Huazhong University of Science and Technology), Xiaofan Liu (Beijing University of Posts and Telecommunications), Pengfei Wang (Beijing University of Posts and Telecommunications), Mingdao Wang (Beijing University of Posts and Telecommunications), Zhichao Feng (Beijing University of Posts and Telecommunications), Kun Zhao (Nanjing University)</li><li><strong>Method:</strong> SGC + R-GAT + Finetune</li><li><strong>Test Accuracy:</strong> 0.7381</li></ul><h4 id="6th-place-DeeperBiggerBetter">6th place: DeeperBiggerBetter</h4><ul><li><strong>Team members:</strong> Guohao Li (KAUST), Hesham Mostafa (Intel Corporation), Jesus Alejandro Zarzar Torano (KAUST), Sami Abu-El-Haija (USC), Marcel Nassar (Intel Labs), Daniel Cummings (Intel Corporation), Sohil Shah (Intel Corporation), Matthias Mueller (Intel Labs), Bernard Ghanem (KAUST)</li><li><strong>Method:</strong> GNN180M</li><li><strong>Test Accuracy:</strong> 0.7353</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>图神经网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blog迁移</title>
    <link href="/2021/11/08/Blog%E8%BF%81%E7%A7%BB/"/>
    <url>/2021/11/08/Blog%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="如何管理我的Blog">如何管理我的Blog</h2><h3 id="需求">需求</h3><p>开始的Blog是在我自己的笔记本上配置的，后来感觉在实验室的时间更多，需要把Blog转移到实验室的主机上。考虑到之后Blog会经常搬家，希望能够找到一种最简单的维护方案，并记录于此。</p><h3 id="原理">原理</h3><p>自己的方案是github+onedrive。<br>首先分拆功能，github只负责保存hexo生成的html文件，并显示。因此对于作者而言，更值得操心的是markdown文件。显然只要有markdown文件，我们还可以找到其他类似hexo或者更加便捷的工具制作自己的博客。当然markdown文件中利用到的hexo各种插件，则有可能因为新平台不支持而失效，这也是需要提前预警的。写博客最好不要太痴迷外观和插件，否则当初博客多漂亮，迁移一次后就有多丑。<br>言归正传，既然对于作者更重要的东西是markdown，那么只需要同步好本地的工作区就好了。这里使用我一如既往喜欢使用的OneDrive，作为OneNote重度用户，我在某淘上购买了OneDrive的会员，速度相比普通用户会提升很多，使用起来没有问题。将整个Blog文件夹放在OneDrive中进行同步。如此以来，即使更换设备，我只需要在新设备上重新部署hexo工具并安装相应的插件即可。<br>今天，自己的新主机终于到了，这里就记录下操作的过程。</p><h3 id="Blog工作区展示">Blog工作区展示</h3><p><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211108214325.png" alt="工作区"><br>如图，** Blog主机迁移 **中就是每次迁移主机，一些需要安装的软件包，如node.js，git安装包以及迁移步骤的markdown说明。</p><h3 id="安装node-js">安装node.js</h3><p>因为win10上安装hexo需要使用node.js。因此如前所述，我将安装包放在了 ** Blog主机迁移 **文件夹中。双击安装node.js。<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211108214740.png" alt="node.js安装测试"><br>安装完后，进入命令行测试，安装成功。</p><h3 id="安装git">安装git</h3><p>git 是hexo用于和github交互的依赖工具，因此也要安装。同样放在** Blog主机迁移 **文件夹中，双击安装。<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211108215005.png" alt="git安装测试"></p><h3 id="安装hexo">安装hexo</h3><p>（可选）设定npm源，用于加速</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>安装hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g<br></code></pre></td></tr></table></figure><h3 id="配置git账户">配置git账户</h3><p>设置git全局的用户名和邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config -l<br>$ git config --global user.name &lt;github account username&gt;<br>$ git config --global user.emial &lt;github account email&gt;<br></code></pre></td></tr></table></figure><p>生成公钥，上传到github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen<br></code></pre></td></tr></table></figure><p>完成上述步骤后，测试git是否可以链接github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -T git@github.com<br></code></pre></td></tr></table></figure><h3 id="同步hexo">同步hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g -d<br></code></pre></td></tr></table></figure><p>至此，同步成功。如有问题，欢迎留言。<br>如果存在 timeout，可以重试几次。<br>或者可以尝试在_config.yml文件中修改ropo仓库链接为ssh协议<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211109090449.png" alt="_config.yml"><br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211109090517.png" alt="hexo同步成功"></p><h3 id="补充">补充</h3><p>今天学习了下，将博客中的图片存放在图床服务上。<br>我采用的方案是vscode+picgo+阿里云OSS。<br><img src="https://johnson-pic-host.oss-cn-beijing.aliyuncs.com/blog/images/20211108213910.png" alt="picgo快捷键"><br>当然，图片也可以由hexo来管理，每次生成文章按照hexo的规则放置在一个文件夹中，距离可以参考<a href="%5Bhexo%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%B9%5D(https://hexo.io/zh-cn/docs/asset-folders)">^2</a></p><h2 id="参考">参考</h2>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>博客使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从valine转向waline</title>
    <link href="/2021/10/31/%E4%BB%8Evaline%E8%BD%AC%E5%90%91waline/"/>
    <url>/2021/10/31/%E4%BB%8Evaline%E8%BD%AC%E5%90%91waline/</url>
    
    <content type="html"><![CDATA[<p>valine真的很舒服，因为自己深受注册登陆的烦恼，觉得根本不是多么重要的一个网页也需要获取我特意注册一个账户才能使用非常麻烦。valine可以把选择权交给用户，并且留下联系方式的过程也非常简单，这一点是我第一次看到valine，就选择其作为博客评论的选择，并为其特意设计了邮件通知系统。然而转头就发现了关于valine的安全性问题，具体参考文章<a href="%5B%E5%9F%BA%E4%BA%8EServerless%E7%9A%84valine%E5%8F%AF%E8%83%BD%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B9%88%E9%A6%99%5D(https://imnerd.org/valine-may-not-so-good.html)">^1</a>。我并不是做前端的，对其中的一些概念并不了解，但是也能看出valine可能没有那么安全。基于此，我选择了在没有太深入绑定之前，转到waline的。</p><h3 id="原理简介">原理简介</h3><p>我理解waline相比于valine，将评论功能拆分为两部分，让服务不直接接触存储，从而避免用户通过js命令行读写内存造成安全性问题。</p><ul><li>vercel上部署服务，通过ServerURL进行内存读写，也是评论功能的主要实现</li><li>leanCloud上进行数据的保存，在构建vercel时提供leanCloud的appID, appKey, masterKey信息。即对于vercel而言，leanCloud也是一个服务。</li></ul><h3 id="过程">过程</h3><p>过程参考<a href="%5Bwaline%E6%90%AD%E5%BB%BA%5D(https://waline.js.org/guide/get-started.html#html-%E5%BC%95%E5%85%A5-%E5%AE%A2%E6%88%B7%E7%AB%AF)">^2</a>: 部署leanCloud, 部署vercel, hexo g -d重构…<br>vercel的部署参考<a href="%5Bwaline%E6%90%AD%E5%BB%BA%5D(https://waline.js.org/guide/get-started.html#html-%E5%BC%95%E5%85%A5-%E5%AE%A2%E6%88%B7%E7%AB%AF)">^2</a>，过程并不复杂。要注意github的邮箱如果之前勾选了保密，注意暂时先点掉，否则会出现vercel拷贝github上的reposity库时不成功的问题。说多了都是泪…</p><h3 id="更多waline功能-3">更多waline功能<a href="%5B%E6%9B%B4%E5%A4%9Awaline%E5%8A%9F%E8%83%BD%5D(https://zzz.zywvvd.com/notes/hexo/theme/fluid/fluid-waline/fluid-waline/)">^3</a></h3><ol><li>设置微信通知<br>主要是使用Server酱，Server酱类似与一个公共的服务, ServerKey写入vercel的环境变量中</li></ol><h3 id="参考链接">参考链接</h3>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>博客使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo和Github搭建公开文档（姑且称之为博客吧）</title>
    <link href="/2021/10/30/Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E5%85%AC%E5%BC%80%E6%96%87%E6%A1%A3%EF%BC%88%E5%A7%91%E4%B8%94%E7%A7%B0%E4%B9%8B%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%90%A7%EF%BC%89/"/>
    <url>/2021/10/30/Hexo%E5%92%8CGithub%E6%90%AD%E5%BB%BA%E5%85%AC%E5%BC%80%E6%96%87%E6%A1%A3%EF%BC%88%E5%A7%91%E4%B8%94%E7%A7%B0%E4%B9%8B%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%90%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>关于创建自己的博客，本科时就使用服务器和wordpress构建过好多次，无奈维护起来过于复杂，很多时候没有写文章的时间还不如维护的时间多。这次心血来潮，也明白了凡事由浅入深，写博客更主要的目的还是想整理一些系统的思考、学习。因此选择了维护和搭建更简单的github+hexo的方案。虽然是静态页面，但是后端通过markdown书写的方式，十分方便自己做一些笔记用。废话不多说，接下来就简单介绍下本次搭建的过程。</p><h3 id="在Github上创建一个reposity">在Github上创建一个reposity</h3><p>reposity是一个项目仓库，就是我们平时fork的项目，简单说就是个高级点的文件夹</p><p>注意以下几个点：</p><ol><li><p>一定是Public，后面才能被公网上访问</p></li><li><p>创建完后，注意在setting中设置一下，才能使用username.github.io访问这个reposity</p></li><li><p>为了方便本地生成静态页面，后期都是git clone到本地，使用git进行维护</p></li></ol><h3 id="为博客选择一个模板">为博客选择一个模板</h3><p>为了省去博客网页的维护，将主要精力放在内容的书写上。“博客生成器”，能够将文本文档有机的整合为html语言。github支持jekyll，类似的还有hexo，hugo,pelican等。</p><p>但是，由于jekyll对win10支持不够友好，一凡折腾之后还是选择了hexo。殊途同归。</p><p>这里给几个模板的例子：</p><ol><li><p><a href="https://zkqiang.cn/">https://zkqiang.cn/</a><br>很漂亮，但是首页的大图容易让人失去写作的专注。我还是想更多聚焦在内容的书写、管理和浏览上。但是看了一圈，这个是最合适的了，所以也是写本文时选用的模板。</p></li><li><p><a href="https://ares-x.com/categories/">https://ares-x.com/categories/</a><br>该方案适合随笔较多。Archives(归档)、Categories(类别)、Tags(标签)字体更小，能够看到更多内容。但是页面美观上就少了很多可能，实在遗憾。</p></li><li><p><a href="https://chhzh123.github.io/blogs/">https://chhzh123.github.io/blogs/</a><br>一个中山大学去了Cornell读PHD的大佬，博客也是非常棒，特别是最后的留言功能！各位如果看到本文由任何问题，也欢迎在下面留言。</p></li></ol><h3 id="hexo使用">hexo使用</h3><ol><li>(可跳过)设定npm源，不然后面npm install很慢</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><ol start="2"><li>创建一个Blog文件夹</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkdir Blog<br>$ <span class="hljs-built_in">cd</span> Blog<br>$ hexo init<br>$ npm install<br></code></pre></td></tr></table></figure><p>结束后，能够看到Blog下面多了一堆文档</p><ol start="2"><li>本地生成页面查看</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo -s<br></code></pre></td></tr></table></figure><p>然后在浏览器访问返回的链接</p><ol start="3"><li>配置本地git账户</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config -l<br>$ git config --global user.name &lt;github account username&gt;<br>$ git config --global user.emial &lt;github account email&gt;<br></code></pre></td></tr></table></figure><p>关于git，后面有可能遇到email和密码不能登陆的问题，问题不大，遇到了多百度，也可以在下面留言。这里主要是github对用户email公开的隐私问题以及密码登陆的安全性问题的限制。</p><ol start="4"><li>链接本地文件和远程仓库<br>首先修改_config.yml文件，设定为自己reposity链接和branch分支。这里注意branch分支，github后来更改为mian了，不再是master。<br>然后执行下述命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g -d<br></code></pre></td></tr></table></figure><p>该命令过后，就相当于git push到了远程仓库。但是需要github反应一会，也可能是浏览器的页面缓存还没有失效，需要等待一会才能看到新的页面。</p><ol start="5"><li>创建新页面<br>具体可以参考hexo官方手册</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>创建draft页面（默认先不上传），再将draft发布为post</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new draft &lt;title&gt;<br>$ hexo publish draft &lt;title&gt;<br></code></pre></td></tr></table></figure><p>创建page页面。page就是类似categories和tags平级的页面，可以汇总新类型页面，通过形如<code>https://erodata.github.io/categories/</code> 访问到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page demo<br></code></pre></td></tr></table></figure><p>如此，在source文件夹下会创建一个demo文件夹，内部有一个index.md文件。修改该index.md文件就可以在该页面制作一个你想要展示的demo网页。<br>具体可以进一步参考</p><ol><li>生成器<br>生成文件，使用 Hexo 生成静态文件快速而且简单。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><ol start="7"><li>valine邮件提醒测试<br>主要参考链接[^6]。所谓邮件提醒，就是后台收到评论后，登陆一个邮箱发送通知给作者。因此需要一个发送邮箱，一个接收邮箱。发送邮箱需要提供密码，为了安全起见，我使用的是QQ邮箱向163邮箱通知。其中，QQ邮箱是我开的小号。最后，云引擎并不需要绑定一个域名，我测试也是成功的。</li></ol><ul><li>监视文件变动<br>Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate --watch<br></code></pre></td></tr></table></figure><ul><li>完成后部署</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate --deploy <span class="hljs-comment"># 也可以简写乘 hexo g -d</span><br>(或)$ hexo deploy --generate <span class="hljs-comment"># 简写为hexo d -g</span><br></code></pre></td></tr></table></figure><h3 id="写作">写作</h3><ol><li><p>Latex数学公式 测试<br>$$ E=mc^2 $$<br>$$ \frac{\partial P(x, y)}{\partial x} = e^y\pi $$</p></li><li><p>Mermaid流程图 测试</p></li></ol><pre><code class=" mermaid">classDiagramClass01 &lt;|-- AveryLongClass : CoolClass03 *-- Class04Class05 o-- Class06Class07 .. Class08Class09 --&gt; C2 : Where am i?Class09 --* C3Class09 --|&gt; Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 &lt;--&gt; C2: Cool label</code></pre><ol start="3"><li>OneDrive同步<br>测试</li></ol><h3 id="参考链接">参考链接</h3><p>[^3]: <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid Github</a><br>[^4]: <a href="https://valine.js.org/hexo.html">留言功能 Valine</a><br>[^5]: <a href="https://hexo.io/themes/">更多hexo主题</a><br>[^6]: <a href="https://dreamhomes.top/posts/202102021138/">valine评论邮件提醒</a><br>[^7]: <a href="https://markdown.com.cn/extended-syntax/footnotes.html">MarkDown官方手册</a><br>[^8]: <a href="https://hexo.fluid-dev.com/posts/fluid-write/">Fluid作者的example博客</a><br>[^9]: <a href="https://oakland.github.io/2016/05/02/hexo-%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E7%AF%87%E6%96%B0%E7%9A%84post/">oakland的博客</a><br>[^10]: <a href="https://xring.info/2018/hexo-category-and-tag-page.html">xring的博客</a><br>[^11]: <a href="https://zhum.in/blog/tutorial/hexo%E4%B8%8B%E6%B8%B2%E6%9F%93mathjax%E9%97%AE%E9%A2%98.html">mathjax行内公式的坑</a></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>博客使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
